/*
 * This task is a bit harder than the previous two.
 * Feel free to change the E3SLinqProvider and any other classes if needed.
 * Possibly, after these changes you will need to rewrite existing tests to make them work again =).
 *
 * The task: implement support of && operator for IQueryable. The final request generated by FTSRequestGenerator, should
 * imply the following rules: https://kb.epam.com/display/EPME3SDEV/Telescope+public+REST+for+data#TelescopepublicRESTfordata-FTSRequestSyntax
 */

using System;
using System.Linq;
using System.Linq.Expressions;
using Expressions.Task3.E3SQueryProvider.Models.Entities;
using Xunit;
using System.Collections.Generic;

namespace Expressions.Task3.E3SQueryProvider.Test
{
    public class E3SAndOperatorSupportTests
    {
        #region SubTask 3: AND operator support

        [Fact]
        public void TestAndQueryable()
        {
            var translator = new ExpressionToFtsRequestTranslator();
            ParameterExpression eParam = Expression.Parameter(typeof(EmployeeEntity), "e");

            // e.Workstation
            MemberExpression workstationMember = Expression.Property(eParam, "Workstation");
            // "EPRUIZHW006"
            ConstantExpression workstationValue = Expression.Constant("EPRUIZHW006");
            // e.Workstation == "EPRUIZHW006"
            BinaryExpression condition1 = Expression.Equal(workstationMember, workstationValue);

            // e.Manager
            MemberExpression managerMember = Expression.Property(eParam, "Manager");
            // "John"
            ConstantExpression managerValue = Expression.Constant("John");
            // e.Manager.StartsWith("John")
            MethodCallExpression condition2 = Expression.Call(
                managerMember, 
                typeof(string).GetMethod("StartsWith", new[] { typeof(string) }), 
                managerValue
            );

            BinaryExpression andExpression = Expression.AndAlso(condition1, condition2);

            LambdaExpression predicateLambda = Expression.Lambda<Func<EmployeeEntity, bool>>(andExpression, eParam);
           
            var queryableSource = new List<EmployeeEntity>().AsQueryable();
            
            MethodCallExpression whereCallExpression = Expression.Call(
                typeof(Queryable),
                "Where",
                new Type[] { typeof(EmployeeEntity) },
                queryableSource.Expression, 
                predicateLambda
            );

            List<string> result = translator.Translate(whereCallExpression);

            // Assertions
            Assert.NotNull(result);
            Assert.Equal(2, result.Count);
            Assert.Contains("Workstation:(EPRUIZHW006)", result);
            Assert.Contains("Manager:(John*)", result);
        }

        #endregion
    }
}
